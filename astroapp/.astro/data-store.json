[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.14.8","content-config-digest","7ae44d14b0b39875","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","posts",["Map",11,12,44,45,74,75,108,109,140,141,170,171,207,208,239,240],"post-2",{"id":11,"data":13,"body":21,"filePath":22,"digest":23,"rendered":24,"legacyId":43},{"title":14,"description":15,"date":16,"tags":17},"Astro + Tailwind：构建高性能博客的最佳实践","分享使用 Astro 和 Tailwind CSS 构建静态博客的经验，探索现代前端开发的最佳实践",["Date","2024-11-28T00:00:00.000Z"],[18,19,20],"Frontend","Astro","Tailwind","选择 Astro 作为博客框架是一个深思熟虑的决定。作为全栈开发者，我尝试过许多技术栈，Astro 的零 JavaScript 默认输出和灵活的组件系统让我印象深刻。\n\n## 为什么选择 Astro\n\nAstro 的核心理念是\"Ship Less JavaScript\"。对于内容驱动的网站，这个理念完美契合需求。它允许我使用熟悉的 React 组件，但只在需要时才发送 JavaScript 到客户端。\n\n静态生成的特性让网站速度极快，SEO 友好，部署简单。配合 Tailwind CSS，我可以快速构建响应式界面，而不用担心 CSS 体积问题。\n\n## Content Collections 的魔力\n\nAstro 的 Content Collections 功能让内容管理变得优雅。使用 Zod 进行类型验证，确保每篇文章的 frontmatter 格式正确。TypeScript 的类型推导让开发体验非常好。\n\n```typescript\nconst posts = await getCollection('posts');\nconst { Content } = await post.render();\n```\n\n简洁的 API 让我专注于内容创作，而不是配置。\n\n## 性能优化策略\n\n1. 使用 Astro 的图片优化组件\n2. 合理使用客户端 Islands\n3. Tailwind CSS 的 JIT 模式\n4. 预渲染所有页面\n\n这些实践让博客的 Lighthouse 得分保持在 95+ 的高水平。","src/content/posts/post-2.md","02e276a44cf59696",{"html":25,"metadata":26},"\u003Cp>选择 Astro 作为博客框架是一个深思熟虑的决定。作为全栈开发者，我尝试过许多技术栈，Astro 的零 JavaScript 默认输出和灵活的组件系统让我印象深刻。\u003C/p>\n\u003Ch2 id=\"为什么选择-astro\">为什么选择 Astro\u003C/h2>\n\u003Cp>Astro 的核心理念是”Ship Less JavaScript”。对于内容驱动的网站，这个理念完美契合需求。它允许我使用熟悉的 React 组件，但只在需要时才发送 JavaScript 到客户端。\u003C/p>\n\u003Cp>静态生成的特性让网站速度极快，SEO 友好，部署简单。配合 Tailwind CSS，我可以快速构建响应式界面，而不用担心 CSS 体积问题。\u003C/p>\n\u003Ch2 id=\"content-collections-的魔力\">Content Collections 的魔力\u003C/h2>\n\u003Cp>Astro 的 Content Collections 功能让内容管理变得优雅。使用 Zod 进行类型验证，确保每篇文章的 frontmatter 格式正确。TypeScript 的类型推导让开发体验非常好。\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"typescript\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">const\u003C/span>\u003Cspan style=\"color:#79B8FF\"> posts\u003C/span>\u003Cspan style=\"color:#F97583\"> =\u003C/span>\u003Cspan style=\"color:#F97583\"> await\u003C/span>\u003Cspan style=\"color:#B392F0\"> getCollection\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(\u003C/span>\u003Cspan style=\"color:#9ECBFF\">'posts'\u003C/span>\u003Cspan style=\"color:#E1E4E8\">);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">const\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> { \u003C/span>\u003Cspan style=\"color:#79B8FF\">Content\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> } \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#F97583\"> await\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> post.\u003C/span>\u003Cspan style=\"color:#B392F0\">render\u003C/span>\u003Cspan style=\"color:#E1E4E8\">();\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>简洁的 API 让我专注于内容创作，而不是配置。\u003C/p>\n\u003Ch2 id=\"性能优化策略\">性能优化策略\u003C/h2>\n\u003Col>\n\u003Cli>使用 Astro 的图片优化组件\u003C/li>\n\u003Cli>合理使用客户端 Islands\u003C/li>\n\u003Cli>Tailwind CSS 的 JIT 模式\u003C/li>\n\u003Cli>预渲染所有页面\u003C/li>\n\u003C/ol>\n\u003Cp>这些实践让博客的 Lighthouse 得分保持在 95+ 的高水平。\u003C/p>",{"headings":27,"localImagePaths":37,"remoteImagePaths":38,"frontmatter":39,"imagePaths":42},[28,32,35],{"depth":29,"slug":30,"text":31},2,"为什么选择-astro","为什么选择 Astro",{"depth":29,"slug":33,"text":34},"content-collections-的魔力","Content Collections 的魔力",{"depth":29,"slug":36,"text":36},"性能优化策略",[],[],{"title":14,"description":15,"date":40,"tags":41},["Date","2024-11-28T00:00:00.000Z"],[18,19,20],[],"post-2.md","post-1",{"id":44,"data":46,"body":53,"filePath":54,"digest":55,"rendered":56,"legacyId":73},{"title":47,"description":48,"date":49,"tags":50},"从 Figma 到代码：设计系统的实践","探索如何将 Figma 设计稿高效转化为可维护的前端代码，建立设计与开发之间的桥梁",["Date","2024-12-01T00:00:00.000Z"],[51,18,52],"Design","Figma","作为一名从 UI 设计师转型到全栈开发的工程师，我深知设计与开发之间的鸿沟。Figma 作为现代设计工具的代表，为我们提供了强大的协作能力，但如何将设计稿高效转化为代码，始终是值得探讨的话题。\n\n## 设计系统的重要性\n\n在过去的设计工作中，我发现建立一套统一的设计系统至关重要。它不仅能提高设计效率，更能让开发团队快速理解设计意图。\n\n使用 Figma 的组件（Components）和变体（Variants）功能，我们可以构建一套可复用的设计资产。这些资产直接对应前端的组件库，比如 React 组件。\n\n## Tailwind CSS 的完美配合\n\n当我开始使用 Tailwind CSS 后，发现它与设计系统的理念不谋而合。在 Figma 中定义的颜色、间距、字体等设计令牌（Design Tokens），可以直接映射到 Tailwind 的配置文件中。\n\n这种对应关系让设计与开发的协作变得更加顺畅。设计师在 Figma 中修改主题色，开发者只需要同步更新 Tailwind 配置即可。\n\n## 工作流优化\n\n我的工作流程通常是：\n1. 在 Figma 中设计组件库\n2. 导出设计令牌到 Tailwind 配置\n3. 使用 React + Tailwind 实现组件\n4. 在 Astro 中组装页面\n\n这个流程让我能够快速迭代，保持设计与实现的一致性。","src/content/posts/post-1.md","b2754861a12eaf39",{"html":57,"metadata":58},"\u003Cp>作为一名从 UI 设计师转型到全栈开发的工程师，我深知设计与开发之间的鸿沟。Figma 作为现代设计工具的代表，为我们提供了强大的协作能力，但如何将设计稿高效转化为代码，始终是值得探讨的话题。\u003C/p>\n\u003Ch2 id=\"设计系统的重要性\">设计系统的重要性\u003C/h2>\n\u003Cp>在过去的设计工作中，我发现建立一套统一的设计系统至关重要。它不仅能提高设计效率，更能让开发团队快速理解设计意图。\u003C/p>\n\u003Cp>使用 Figma 的组件（Components）和变体（Variants）功能，我们可以构建一套可复用的设计资产。这些资产直接对应前端的组件库，比如 React 组件。\u003C/p>\n\u003Ch2 id=\"tailwind-css-的完美配合\">Tailwind CSS 的完美配合\u003C/h2>\n\u003Cp>当我开始使用 Tailwind CSS 后，发现它与设计系统的理念不谋而合。在 Figma 中定义的颜色、间距、字体等设计令牌（Design Tokens），可以直接映射到 Tailwind 的配置文件中。\u003C/p>\n\u003Cp>这种对应关系让设计与开发的协作变得更加顺畅。设计师在 Figma 中修改主题色，开发者只需要同步更新 Tailwind 配置即可。\u003C/p>\n\u003Ch2 id=\"工作流优化\">工作流优化\u003C/h2>\n\u003Cp>我的工作流程通常是：\u003C/p>\n\u003Col>\n\u003Cli>在 Figma 中设计组件库\u003C/li>\n\u003Cli>导出设计令牌到 Tailwind 配置\u003C/li>\n\u003Cli>使用 React + Tailwind 实现组件\u003C/li>\n\u003Cli>在 Astro 中组装页面\u003C/li>\n\u003C/ol>\n\u003Cp>这个流程让我能够快速迭代，保持设计与实现的一致性。\u003C/p>",{"headings":59,"localImagePaths":67,"remoteImagePaths":68,"frontmatter":69,"imagePaths":72},[60,62,65],{"depth":29,"slug":61,"text":61},"设计系统的重要性",{"depth":29,"slug":63,"text":64},"tailwind-css-的完美配合","Tailwind CSS 的完美配合",{"depth":29,"slug":66,"text":66},"工作流优化",[],[],{"title":47,"description":48,"date":70,"tags":71},["Date","2024-12-01T00:00:00.000Z"],[51,18,52],[],"post-1.md","post-8",{"id":74,"data":76,"body":84,"filePath":85,"digest":86,"rendered":87,"legacyId":107},{"title":77,"description":78,"date":79,"tags":80},"数据库选型：MySQL vs PostgreSQL","对比 MySQL 和 PostgreSQL 的特性，分享数据库选型的思考",["Date","2024-11-01T00:00:00.000Z"],[81,82,83],"Database","MySQL","PostgreSQL","在后端开发中，数据库的选择往往会影响整个项目的架构。MySQL 和 PostgreSQL 是两个最流行的开源关系数据库，各有优势。\n\n## MySQL 的特点\n\nMySQL 以简单易用著称。在我的早期项目中，MySQL 是首选。它的安装配置简单，生态系统成熟，网上资料丰富。\n\n对于读多写少的场景，MySQL 的性能表现优异。InnoDB 引擎提供了事务支持，满足大部分业务需求。\n\n## PostgreSQL 的优势\n\n随着项目复杂度增加，我开始更多地使用 PostgreSQL。它的功能更加丰富：\n- 完整的 JSON/JSONB 支持\n- 强大的全文搜索\n- 地理信息系统（PostGIS）\n- 丰富的数据类型\n\n特别是 JSONB 类型，让 PostgreSQL 在处理半结构化数据时非常灵活，几乎可以当作文档数据库使用。\n\n## 如何选择\n\n我的经验是：\n- 项目初期，快速迭代，可以选择 MySQL\n- 需要复杂查询、JSON 数据，选择 PostgreSQL\n- 已有技术栈，优先考虑团队熟悉的\n\n在我的新项目中，基本都选择 PostgreSQL。它的稳定性和功能性让我很有信心。\n\n## 性能优化\n\n无论选择哪个数据库，性能优化的思路类似：\n- 合理设计索引\n- 优化查询语句\n- 定期分析和维护\n- 适当的分库分表\n\n数据库是应用的基石，值得投入时间深入学习和优化。","src/content/posts/post-8.md","1671fd2dc0e06704",{"html":88,"metadata":89},"\u003Cp>在后端开发中，数据库的选择往往会影响整个项目的架构。MySQL 和 PostgreSQL 是两个最流行的开源关系数据库，各有优势。\u003C/p>\n\u003Ch2 id=\"mysql-的特点\">MySQL 的特点\u003C/h2>\n\u003Cp>MySQL 以简单易用著称。在我的早期项目中，MySQL 是首选。它的安装配置简单，生态系统成熟，网上资料丰富。\u003C/p>\n\u003Cp>对于读多写少的场景，MySQL 的性能表现优异。InnoDB 引擎提供了事务支持，满足大部分业务需求。\u003C/p>\n\u003Ch2 id=\"postgresql-的优势\">PostgreSQL 的优势\u003C/h2>\n\u003Cp>随着项目复杂度增加，我开始更多地使用 PostgreSQL。它的功能更加丰富：\u003C/p>\n\u003Cul>\n\u003Cli>完整的 JSON/JSONB 支持\u003C/li>\n\u003Cli>强大的全文搜索\u003C/li>\n\u003Cli>地理信息系统（PostGIS）\u003C/li>\n\u003Cli>丰富的数据类型\u003C/li>\n\u003C/ul>\n\u003Cp>特别是 JSONB 类型，让 PostgreSQL 在处理半结构化数据时非常灵活，几乎可以当作文档数据库使用。\u003C/p>\n\u003Ch2 id=\"如何选择\">如何选择\u003C/h2>\n\u003Cp>我的经验是：\u003C/p>\n\u003Cul>\n\u003Cli>项目初期，快速迭代，可以选择 MySQL\u003C/li>\n\u003Cli>需要复杂查询、JSON 数据，选择 PostgreSQL\u003C/li>\n\u003Cli>已有技术栈，优先考虑团队熟悉的\u003C/li>\n\u003C/ul>\n\u003Cp>在我的新项目中，基本都选择 PostgreSQL。它的稳定性和功能性让我很有信心。\u003C/p>\n\u003Ch2 id=\"性能优化\">性能优化\u003C/h2>\n\u003Cp>无论选择哪个数据库，性能优化的思路类似：\u003C/p>\n\u003Cul>\n\u003Cli>合理设计索引\u003C/li>\n\u003Cli>优化查询语句\u003C/li>\n\u003Cli>定期分析和维护\u003C/li>\n\u003Cli>适当的分库分表\u003C/li>\n\u003C/ul>\n\u003Cp>数据库是应用的基石，值得投入时间深入学习和优化。\u003C/p>",{"headings":90,"localImagePaths":101,"remoteImagePaths":102,"frontmatter":103,"imagePaths":106},[91,94,97,99],{"depth":29,"slug":92,"text":93},"mysql-的特点","MySQL 的特点",{"depth":29,"slug":95,"text":96},"postgresql-的优势","PostgreSQL 的优势",{"depth":29,"slug":98,"text":98},"如何选择",{"depth":29,"slug":100,"text":100},"性能优化",[],[],{"title":77,"description":78,"date":104,"tags":105},["Date","2024-11-01T00:00:00.000Z"],[81,82,83],[],"post-8.md","post-3",{"id":108,"data":110,"body":117,"filePath":118,"digest":119,"rendered":120,"legacyId":139},{"title":111,"description":112,"date":113,"tags":114},"FastAPI + PostgreSQL：构建现代后端 API","使用 FastAPI 和 PostgreSQL 构建高性能 RESTful API 的实战经验",["Date","2024-11-25T00:00:00.000Z"],[115,116,81],"Backend","Python","从产品经理转型到全栈开发后，我发现 FastAPI 是 Python 生态中最令人兴奋的框架之一。它的性能、开发体验和自动文档生成功能，让后端开发变得高效而愉悦。\n\n## FastAPI 的优势\n\nFastAPI 基于 Python 的类型注解，提供了出色的开发者体验。自动生成的 OpenAPI 文档让前后端协作更加顺畅，这在我做产品经理时深有体会。\n\n异步支持让它能够处理高并发请求，性能媲美 Node.js。配合 Pydantic 进行数据验证，代码既简洁又可靠。\n\n## PostgreSQL 的选择\n\n选择 PostgreSQL 作为主数据库，是因为它强大的功能集和可靠性。JSON 字段支持让它在处理半结构化数据时非常灵活，JSONB 索引更是提供了出色的查询性能。\n\n使用 SQLAlchemy 作为 ORM，结合 Alembic 进行数据库迁移管理，整个开发流程非常规范。\n\n## API 设计最佳实践\n\n从产品角度思考 API 设计：\n- RESTful 规范的路由设计\n- 合理的状态码使用\n- 清晰的错误消息\n- 完善的文档\n\n这些实践让 API 不仅对开发者友好，也便于产品迭代和维护。","src/content/posts/post-3.md","064678d1b688bc3e",{"html":121,"metadata":122},"\u003Cp>从产品经理转型到全栈开发后，我发现 FastAPI 是 Python 生态中最令人兴奋的框架之一。它的性能、开发体验和自动文档生成功能，让后端开发变得高效而愉悦。\u003C/p>\n\u003Ch2 id=\"fastapi-的优势\">FastAPI 的优势\u003C/h2>\n\u003Cp>FastAPI 基于 Python 的类型注解，提供了出色的开发者体验。自动生成的 OpenAPI 文档让前后端协作更加顺畅，这在我做产品经理时深有体会。\u003C/p>\n\u003Cp>异步支持让它能够处理高并发请求，性能媲美 Node.js。配合 Pydantic 进行数据验证，代码既简洁又可靠。\u003C/p>\n\u003Ch2 id=\"postgresql-的选择\">PostgreSQL 的选择\u003C/h2>\n\u003Cp>选择 PostgreSQL 作为主数据库，是因为它强大的功能集和可靠性。JSON 字段支持让它在处理半结构化数据时非常灵活，JSONB 索引更是提供了出色的查询性能。\u003C/p>\n\u003Cp>使用 SQLAlchemy 作为 ORM，结合 Alembic 进行数据库迁移管理，整个开发流程非常规范。\u003C/p>\n\u003Ch2 id=\"api-设计最佳实践\">API 设计最佳实践\u003C/h2>\n\u003Cp>从产品角度思考 API 设计：\u003C/p>\n\u003Cul>\n\u003Cli>RESTful 规范的路由设计\u003C/li>\n\u003Cli>合理的状态码使用\u003C/li>\n\u003Cli>清晰的错误消息\u003C/li>\n\u003Cli>完善的文档\u003C/li>\n\u003C/ul>\n\u003Cp>这些实践让 API 不仅对开发者友好，也便于产品迭代和维护。\u003C/p>",{"headings":123,"localImagePaths":133,"remoteImagePaths":134,"frontmatter":135,"imagePaths":138},[124,127,130],{"depth":29,"slug":125,"text":126},"fastapi-的优势","FastAPI 的优势",{"depth":29,"slug":128,"text":129},"postgresql-的选择","PostgreSQL 的选择",{"depth":29,"slug":131,"text":132},"api-设计最佳实践","API 设计最佳实践",[],[],{"title":111,"description":112,"date":136,"tags":137},["Date","2024-11-25T00:00:00.000Z"],[115,116,81],[],"post-3.md","post-4",{"id":140,"data":142,"body":149,"filePath":150,"digest":151,"rendered":152,"legacyId":169},{"title":143,"description":144,"date":145,"tags":146},"React Hooks 深入理解与实践","从实战角度深入探讨 React Hooks 的使用技巧和最佳实践",["Date","2024-11-20T00:00:00.000Z"],[18,147,148],"React","JavaScript","React Hooks 改变了我们编写组件的方式。作为一名长期使用 React 的开发者，我见证了从 Class 组件到函数组件的演进。\n\n## Hooks 的核心思想\n\nHooks 让状态逻辑可以独立于组件树重用。useState、useEffect 这些基础 Hooks 解决了大部分场景，而自定义 Hooks 则让代码组织更加优雅。\n\n在实际项目中，我经常创建自定义 Hooks 来封装通用逻辑：\n- useLocalStorage：持久化状态\n- useFetch：数据获取\n- useDebounce：防抖处理\n\n## 性能优化\n\n合理使用 useMemo 和 useCallback 可以避免不必要的重渲染。但过度优化反而会降低代码可读性，需要找到平衡点。\n\nReact DevTools 的 Profiler 是我常用的工具，它能清晰地展示组件渲染的性能瓶颈。\n\n## TypeScript 的加持\n\n结合 TypeScript，Hooks 的类型推导让开发体验更上一层楼。泛型的使用让自定义 Hooks 既灵活又类型安全。\n\n这种强类型的开发方式，大大减少了运行时错误，提高了代码质量。","src/content/posts/post-4.md","ad813dcf1a1b76aa",{"html":153,"metadata":154},"\u003Cp>React Hooks 改变了我们编写组件的方式。作为一名长期使用 React 的开发者，我见证了从 Class 组件到函数组件的演进。\u003C/p>\n\u003Ch2 id=\"hooks-的核心思想\">Hooks 的核心思想\u003C/h2>\n\u003Cp>Hooks 让状态逻辑可以独立于组件树重用。useState、useEffect 这些基础 Hooks 解决了大部分场景，而自定义 Hooks 则让代码组织更加优雅。\u003C/p>\n\u003Cp>在实际项目中，我经常创建自定义 Hooks 来封装通用逻辑：\u003C/p>\n\u003Cul>\n\u003Cli>useLocalStorage：持久化状态\u003C/li>\n\u003Cli>useFetch：数据获取\u003C/li>\n\u003Cli>useDebounce：防抖处理\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"性能优化\">性能优化\u003C/h2>\n\u003Cp>合理使用 useMemo 和 useCallback 可以避免不必要的重渲染。但过度优化反而会降低代码可读性，需要找到平衡点。\u003C/p>\n\u003Cp>React DevTools 的 Profiler 是我常用的工具，它能清晰地展示组件渲染的性能瓶颈。\u003C/p>\n\u003Ch2 id=\"typescript-的加持\">TypeScript 的加持\u003C/h2>\n\u003Cp>结合 TypeScript，Hooks 的类型推导让开发体验更上一层楼。泛型的使用让自定义 Hooks 既灵活又类型安全。\u003C/p>\n\u003Cp>这种强类型的开发方式，大大减少了运行时错误，提高了代码质量。\u003C/p>",{"headings":155,"localImagePaths":163,"remoteImagePaths":164,"frontmatter":165,"imagePaths":168},[156,159,160],{"depth":29,"slug":157,"text":158},"hooks-的核心思想","Hooks 的核心思想",{"depth":29,"slug":100,"text":100},{"depth":29,"slug":161,"text":162},"typescript-的加持","TypeScript 的加持",[],[],{"title":143,"description":144,"date":166,"tags":167},["Date","2024-11-20T00:00:00.000Z"],[18,147,148],[],"post-4.md","post-5",{"id":170,"data":172,"body":179,"filePath":180,"digest":181,"rendered":182,"legacyId":206},{"title":173,"description":174,"date":175,"tags":176},"从 UI 设计到全栈开发：我的转型之路","分享从 UI 设计师到全栈开发工程师的成长历程与思考",["Date","2024-11-15T00:00:00.000Z"],[177,51,178],"Career","Development","2015 年，我开始了 UI 设计师的职业生涯。那时的我热衷于 Photoshop 和 Sketch，痴迷于像素级的完美。九年后的今天，我成为了一名全栈开发工程师。这段旅程充满挑战，也收获颇丰。\n\n## UI 设计师时期（2015-2019）\n\n最初的四年，我专注于视觉设计。从 Photoshop 到 Sketch，再到 Figma，工具在变化，但对美的追求始终不变。这段经历让我培养了对细节的敏感度和对用户体验的理解。\n\n设计不只是让界面好看，更重要的是解决用户的问题。这个认知为我后来的转型埋下了伏笔。\n\n## 交互设计师（2019-2020）\n\n向交互设计的转变是自然而然的。我开始思考用户如何与产品互动，关注信息架构和交互流程。Axure 成为我的新工具，原型设计让我的想法更容易被团队理解。\n\n这一年的经历让我意识到，设计不能脱离实现。了解技术的可行性，能让设计更有落地性。\n\n## 产品经理（2020-2023）\n\n产品经理的经历拓宽了我的视野。我开始从商业角度思考问题，学会平衡用户需求、商业目标和技术实现。\n\n这三年让我理解了产品的完整生命周期，也让我意识到，只有真正理解技术，才能做出更好的决策。\n\n## 全栈开发（2023-至今）\n\n下定决心学习编程，是我职业生涯中最重要的决定之一。从 JavaScript 开始，到 TypeScript、React，再到 Python、Rust，每一门技术都打开了新世界的大门。\n\n设计背景让我对用户体验有天然的敏感度，产品思维让我能够全局思考问题。现在作为开发者，我能够将想法直接变为现实，这种感觉非常美妙。\n\n## 未来展望\n\n技术在快速发展，学习永无止境。从设计到开发的这条路并不平坦，但每一步都值得。我相信，多元的背景会成为我最大的优势。","src/content/posts/post-5.md","78cf270d67a59626",{"html":183,"metadata":184},"\u003Cp>2015 年，我开始了 UI 设计师的职业生涯。那时的我热衷于 Photoshop 和 Sketch，痴迷于像素级的完美。九年后的今天，我成为了一名全栈开发工程师。这段旅程充满挑战，也收获颇丰。\u003C/p>\n\u003Ch2 id=\"ui-设计师时期2015-2019\">UI 设计师时期（2015-2019）\u003C/h2>\n\u003Cp>最初的四年，我专注于视觉设计。从 Photoshop 到 Sketch，再到 Figma，工具在变化，但对美的追求始终不变。这段经历让我培养了对细节的敏感度和对用户体验的理解。\u003C/p>\n\u003Cp>设计不只是让界面好看，更重要的是解决用户的问题。这个认知为我后来的转型埋下了伏笔。\u003C/p>\n\u003Ch2 id=\"交互设计师2019-2020\">交互设计师（2019-2020）\u003C/h2>\n\u003Cp>向交互设计的转变是自然而然的。我开始思考用户如何与产品互动，关注信息架构和交互流程。Axure 成为我的新工具，原型设计让我的想法更容易被团队理解。\u003C/p>\n\u003Cp>这一年的经历让我意识到，设计不能脱离实现。了解技术的可行性，能让设计更有落地性。\u003C/p>\n\u003Ch2 id=\"产品经理2020-2023\">产品经理（2020-2023）\u003C/h2>\n\u003Cp>产品经理的经历拓宽了我的视野。我开始从商业角度思考问题，学会平衡用户需求、商业目标和技术实现。\u003C/p>\n\u003Cp>这三年让我理解了产品的完整生命周期，也让我意识到，只有真正理解技术，才能做出更好的决策。\u003C/p>\n\u003Ch2 id=\"全栈开发2023-至今\">全栈开发（2023-至今）\u003C/h2>\n\u003Cp>下定决心学习编程，是我职业生涯中最重要的决定之一。从 JavaScript 开始，到 TypeScript、React，再到 Python、Rust，每一门技术都打开了新世界的大门。\u003C/p>\n\u003Cp>设计背景让我对用户体验有天然的敏感度，产品思维让我能够全局思考问题。现在作为开发者，我能够将想法直接变为现实，这种感觉非常美妙。\u003C/p>\n\u003Ch2 id=\"未来展望\">未来展望\u003C/h2>\n\u003Cp>技术在快速发展，学习永无止境。从设计到开发的这条路并不平坦，但每一步都值得。我相信，多元的背景会成为我最大的优势。\u003C/p>",{"headings":185,"localImagePaths":200,"remoteImagePaths":201,"frontmatter":202,"imagePaths":205},[186,189,192,195,198],{"depth":29,"slug":187,"text":188},"ui-设计师时期2015-2019","UI 设计师时期（2015-2019）",{"depth":29,"slug":190,"text":191},"交互设计师2019-2020","交互设计师（2019-2020）",{"depth":29,"slug":193,"text":194},"产品经理2020-2023","产品经理（2020-2023）",{"depth":29,"slug":196,"text":197},"全栈开发2023-至今","全栈开发（2023-至今）",{"depth":29,"slug":199,"text":199},"未来展望",[],[],{"title":173,"description":174,"date":203,"tags":204},["Date","2024-11-15T00:00:00.000Z"],[177,51,178],[],"post-5.md","post-6",{"id":207,"data":209,"body":216,"filePath":217,"digest":218,"rendered":219,"legacyId":238},{"title":210,"description":211,"date":212,"tags":213},"Node.js 微服务架构实践","探索使用 Node.js 构建微服务架构的经验和最佳实践",["Date","2024-11-10T00:00:00.000Z"],[115,214,215],"Node.js","Architecture","在现代后端开发中，微服务架构已经成为主流。Node.js 的事件驱动和非阻塞 I/O 特性，让它成为构建微服务的理想选择。\n\n## 微服务的优势与挑战\n\n微服务架构的核心思想是将大型应用拆分为小型、独立的服务。每个服务专注于特定的业务功能，可以独立部署和扩展。\n\n优势显而易见：\n- 技术栈灵活\n- 独立部署\n- 容错性强\n- 易于扩展\n\n但挑战同样存在：服务间通信、数据一致性、分布式追踪等问题需要仔细设计。\n\n## Node.js 的适用场景\n\nNode.js 特别适合：\n- I/O 密集型应用\n- 实时通信服务\n- API Gateway\n- BFF（Backend For Frontend）\n\n在我的项目中，使用 Express 或 Fastify 构建 RESTful API，配合 Socket.io 实现实时功能，效果非常好。\n\n## 服务间通信\n\nREST API 和消息队列是我常用的通信方式。对于同步调用，使用 HTTP/REST；对于异步处理，使用 RabbitMQ 或 Redis。\n\ngRPC 在某些场景下也是不错的选择，特别是需要高性能内部服务通信时。\n\n## 监控与日志\n\n分布式系统的监控至关重要。我使用：\n- Prometheus + Grafana 监控指标\n- ELK Stack 收集和分析日志\n- Jaeger 进行分布式追踪\n\n这些工具让我能够快速定位问题，保证系统的稳定运行。","src/content/posts/post-6.md","52a8b5f0b074ab46",{"html":220,"metadata":221},"\u003Cp>在现代后端开发中，微服务架构已经成为主流。Node.js 的事件驱动和非阻塞 I/O 特性，让它成为构建微服务的理想选择。\u003C/p>\n\u003Ch2 id=\"微服务的优势与挑战\">微服务的优势与挑战\u003C/h2>\n\u003Cp>微服务架构的核心思想是将大型应用拆分为小型、独立的服务。每个服务专注于特定的业务功能，可以独立部署和扩展。\u003C/p>\n\u003Cp>优势显而易见：\u003C/p>\n\u003Cul>\n\u003Cli>技术栈灵活\u003C/li>\n\u003Cli>独立部署\u003C/li>\n\u003Cli>容错性强\u003C/li>\n\u003Cli>易于扩展\u003C/li>\n\u003C/ul>\n\u003Cp>但挑战同样存在：服务间通信、数据一致性、分布式追踪等问题需要仔细设计。\u003C/p>\n\u003Ch2 id=\"nodejs-的适用场景\">Node.js 的适用场景\u003C/h2>\n\u003Cp>Node.js 特别适合：\u003C/p>\n\u003Cul>\n\u003Cli>I/O 密集型应用\u003C/li>\n\u003Cli>实时通信服务\u003C/li>\n\u003Cli>API Gateway\u003C/li>\n\u003Cli>BFF（Backend For Frontend）\u003C/li>\n\u003C/ul>\n\u003Cp>在我的项目中，使用 Express 或 Fastify 构建 RESTful API，配合 Socket.io 实现实时功能，效果非常好。\u003C/p>\n\u003Ch2 id=\"服务间通信\">服务间通信\u003C/h2>\n\u003Cp>REST API 和消息队列是我常用的通信方式。对于同步调用，使用 HTTP/REST；对于异步处理，使用 RabbitMQ 或 Redis。\u003C/p>\n\u003Cp>gRPC 在某些场景下也是不错的选择，特别是需要高性能内部服务通信时。\u003C/p>\n\u003Ch2 id=\"监控与日志\">监控与日志\u003C/h2>\n\u003Cp>分布式系统的监控至关重要。我使用：\u003C/p>\n\u003Cul>\n\u003Cli>Prometheus + Grafana 监控指标\u003C/li>\n\u003Cli>ELK Stack 收集和分析日志\u003C/li>\n\u003Cli>Jaeger 进行分布式追踪\u003C/li>\n\u003C/ul>\n\u003Cp>这些工具让我能够快速定位问题，保证系统的稳定运行。\u003C/p>",{"headings":222,"localImagePaths":232,"remoteImagePaths":233,"frontmatter":234,"imagePaths":237},[223,225,228,230],{"depth":29,"slug":224,"text":224},"微服务的优势与挑战",{"depth":29,"slug":226,"text":227},"nodejs-的适用场景","Node.js 的适用场景",{"depth":29,"slug":229,"text":229},"服务间通信",{"depth":29,"slug":231,"text":231},"监控与日志",[],[],{"title":210,"description":211,"date":235,"tags":236},["Date","2024-11-10T00:00:00.000Z"],[115,214,215],[],"post-6.md","post-7",{"id":239,"data":241,"body":248,"filePath":249,"digest":250,"rendered":251,"legacyId":270},{"title":242,"description":243,"date":244,"tags":245},"Rust 初探：系统编程的新选择","学习 Rust 的心得体会，探索这门语言的独特魅力",["Date","2024-11-05T00:00:00.000Z"],[115,246,247],"Rust","Programming","作为一名主要使用 JavaScript 和 Python 的开发者，学习 Rust 是一次全新的体验。这门语言的严谨性和性能让我印象深刻。\n\n## 为什么学习 Rust\n\nRust 承诺\"无畏并发\"和\"零成本抽象\"。在不需要垃圾回收的情况下保证内存安全，这在系统编程语言中是独一无二的。\n\n我学习 Rust 的动机很简单：想要理解更底层的计算机原理，同时掌握一门高性能的语言。\n\n## 所有权系统\n\nRust 的所有权系统是它最独特的特性。刚开始会觉得很\"别扭\"，编译器似乎总是在\"找茬\"。但随着理解加深，我意识到这些限制实际上是在帮助我写出更好的代码。\n\n借用检查器强制我思考数据的生命周期，这让很多潜在的 bug 在编译期就被发现了。\n\n## 实践项目\n\n我尝试用 Rust 重写了一些 Node.js 工具，性能提升非常明显。虽然开发效率不如动态语言，但产出的程序稳定可靠。\n\n在一些性能关键的场景，比如数据处理、文件操作，Rust 的优势非常明显。\n\n## 学习曲线\n\n不得不说，Rust 的学习曲线很陡峭。但\"The Rust Programming Language\"这本书写得非常好，Rust 社区也很友好。\n\n现在我在一些小项目中使用 Rust，逐步积累经验。虽然还谈不上精通，但已经能感受到它的魅力。","src/content/posts/post-7.md","a07c08f92e2a5dc4",{"html":252,"metadata":253},"\u003Cp>作为一名主要使用 JavaScript 和 Python 的开发者，学习 Rust 是一次全新的体验。这门语言的严谨性和性能让我印象深刻。\u003C/p>\n\u003Ch2 id=\"为什么学习-rust\">为什么学习 Rust\u003C/h2>\n\u003Cp>Rust 承诺”无畏并发”和”零成本抽象”。在不需要垃圾回收的情况下保证内存安全，这在系统编程语言中是独一无二的。\u003C/p>\n\u003Cp>我学习 Rust 的动机很简单：想要理解更底层的计算机原理，同时掌握一门高性能的语言。\u003C/p>\n\u003Ch2 id=\"所有权系统\">所有权系统\u003C/h2>\n\u003Cp>Rust 的所有权系统是它最独特的特性。刚开始会觉得很”别扭”，编译器似乎总是在”找茬”。但随着理解加深，我意识到这些限制实际上是在帮助我写出更好的代码。\u003C/p>\n\u003Cp>借用检查器强制我思考数据的生命周期，这让很多潜在的 bug 在编译期就被发现了。\u003C/p>\n\u003Ch2 id=\"实践项目\">实践项目\u003C/h2>\n\u003Cp>我尝试用 Rust 重写了一些 Node.js 工具，性能提升非常明显。虽然开发效率不如动态语言，但产出的程序稳定可靠。\u003C/p>\n\u003Cp>在一些性能关键的场景，比如数据处理、文件操作，Rust 的优势非常明显。\u003C/p>\n\u003Ch2 id=\"学习曲线\">学习曲线\u003C/h2>\n\u003Cp>不得不说，Rust 的学习曲线很陡峭。但”The Rust Programming Language”这本书写得非常好，Rust 社区也很友好。\u003C/p>\n\u003Cp>现在我在一些小项目中使用 Rust，逐步积累经验。虽然还谈不上精通，但已经能感受到它的魅力。\u003C/p>",{"headings":254,"localImagePaths":264,"remoteImagePaths":265,"frontmatter":266,"imagePaths":269},[255,258,260,262],{"depth":29,"slug":256,"text":257},"为什么学习-rust","为什么学习 Rust",{"depth":29,"slug":259,"text":259},"所有权系统",{"depth":29,"slug":261,"text":261},"实践项目",{"depth":29,"slug":263,"text":263},"学习曲线",[],[],{"title":242,"description":243,"date":267,"tags":268},["Date","2024-11-05T00:00:00.000Z"],[115,246,247],[],"post-7.md"]